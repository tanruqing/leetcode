### 题目描述
给出两个 非空 的链表用来表示两个非负的整数。其中，它们各自的位数是按照 逆序 的方式存储的，并且它们的每个节点只能存储 一位 数字。

如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。

您可以假设除了数字 0 之外，这两个数都不会以 0 开头。

示例：

>输入：(2 -> 4 -> 3) + (5 -> 6 -> 4)  
>输出：7 -> 0 -> 8  
>原因：342 + 465 = 807

### 解决思路：
假设两个列表分别为l1和l2，进位用变量carry表示。就像在纸上计算两个数字的和一样，我们首先从最低有效位也就是l1和l2的表头开始相加。由于每个数字都处于[0,9]范围内，因此两数相加之和有可能会出现"溢出"。例如，6+8=14，我们会将当前位的数值置为4，并将进位carry=1带入下一次迭代。
进位carry必定是0或者1，因为两个数字相加（考虑进位）最大和为9+9+1=19。

### 需要注意的情况
- 当一个列表比另一个列表长时
>l1=[0, 1]  
>l2=[0, 1, 2]

- 求和运算最后出现额外的进位
>l1=[9, 9]  
>l2=[1]

### 伪代码
- 将当前节点初始化为返回列表的哑节点
- 将进位carry初始化为0
- 令p和q分别指向l1和l2的头部
- 遍历列表l1和l2直至到达它们的尾部
- 将x设置节点p的值。如果p到达l1的末尾，则将其值设置为0
- 将y设为节点q的值。如果q到达l2的末尾，则将其值设置为0
- 设置sum = x + y + carry
- 更新进位的值：carry = sum / 10
- 创建一个数值为(sum mod 10)的新节点，并将其设置为当前节点的下一个节点，然后将当前节点设置前进到下一个节点
- 同时，将p和q前进到下一个节点
- 检查carry = 1是否成立，如果成立，则向返回列表里追加一个含有数字1的新节点
- 返回哑节点的下一个节点

请注意，这里用哑节点来简化代码。如果没有哑节点，则必须编写额外的条件语句来初始化表头的值

### 复杂度分析
- 时间复杂度：O(max(m, n))，假设m和n分别表示l1和l2的长度，上面的算法最多重复max(m, n)次
- 空间复杂度：O(max(m, n))，新列表的长度最多为max(m, n) + 1